// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace InfinityFlow.DigitalOcean.Client.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class Load_balancer_base : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>This field has been deprecated. You can no longer specify an algorithm for load balancers.</summary>
        [Obsolete("")]
        public global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_algorithm? Algorithm { get; set; }
        /// <summary>A time value given in ISO8601 combined date and time format that represents when the load balancer was created.</summary>
        public DateTimeOffset? CreatedAt { get; private set; }
        /// <summary>A boolean value indicating whether to disable automatic DNS record creation for Let&apos;s Encrypt certificates that are added to the load balancer.</summary>
        public bool? DisableLetsEncryptDnsRecords { get; set; }
        /// <summary>An array of objects specifying the domain configurations for a Global load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::InfinityFlow.DigitalOcean.Client.Models.Domains>? Domains { get; set; }
#nullable restore
#else
        public List<global::InfinityFlow.DigitalOcean.Client.Models.Domains> Domains { get; set; }
#endif
        /// <summary>A boolean value indicating whether HTTP keepalive connections are maintained to target Droplets.</summary>
        public bool? EnableBackendKeepalive { get; set; }
        /// <summary>A boolean value indicating whether PROXY Protocol is in use.</summary>
        public bool? EnableProxyProtocol { get; set; }
        /// <summary>An object specifying allow and deny rules to control traffic to the load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::InfinityFlow.DigitalOcean.Client.Models.Lb_firewall? Firewall { get; set; }
#nullable restore
#else
        public global::InfinityFlow.DigitalOcean.Client.Models.Lb_firewall Firewall { get; set; }
#endif
        /// <summary>An array of objects specifying the forwarding rules for a load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::InfinityFlow.DigitalOcean.Client.Models.Forwarding_rule>? ForwardingRules { get; set; }
#nullable restore
#else
        public List<global::InfinityFlow.DigitalOcean.Client.Models.Forwarding_rule> ForwardingRules { get; set; }
#endif
        /// <summary>An object specifying forwarding configurations for a Global load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::InfinityFlow.DigitalOcean.Client.Models.Glb_settings? GlbSettings { get; set; }
#nullable restore
#else
        public global::InfinityFlow.DigitalOcean.Client.Models.Glb_settings GlbSettings { get; set; }
#endif
        /// <summary>An object specifying health check settings for the load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::InfinityFlow.DigitalOcean.Client.Models.Health_check? HealthCheck { get; set; }
#nullable restore
#else
        public global::InfinityFlow.DigitalOcean.Client.Models.Health_check HealthCheck { get; set; }
#endif
        /// <summary>An integer value which configures the idle timeout for HTTP requests to the target droplets.</summary>
        public int? HttpIdleTimeoutSeconds { get; set; }
        /// <summary>A unique ID that can be used to identify and reference a load balancer.</summary>
        public Guid? Id { get; private set; }
        /// <summary>An attribute containing the public-facing IP address of the load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Ip { get; private set; }
#nullable restore
#else
        public string Ip { get; private set; }
#endif
        /// <summary>An attribute containing the public-facing IPv6 address of the load balancer. Note that this feature is currently in private preview.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Ipv6 { get; private set; }
#nullable restore
#else
        public string Ipv6 { get; private set; }
#endif
        /// <summary>A human-readable name for a load balancer instance.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Name { get; set; }
#nullable restore
#else
        public string Name { get; set; }
#endif
        /// <summary>A string indicating whether the load balancer should be external or internal. Internal load balancers have no public IPs and are only accessible to resources on the same VPC network. This property cannot be updated after creating the load balancer.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network? Network { get; set; }
        /// <summary>A string indicating whether the load balancer will support IPv4 or both IPv4 and IPv6 networking. This property cannot be updated after creating the load balancer. Note that this feature is in private preview.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network_stack? NetworkStack { get; set; }
        /// <summary>The ID of the project that the load balancer is associated with. If no ID is provided at creation, the load balancer associates with the user&apos;s default project. If an invalid project ID is provided, the load balancer will not be created.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProjectId { get; set; }
#nullable restore
#else
        public string ProjectId { get; set; }
#endif
        /// <summary>A boolean value indicating whether HTTP requests to the load balancer on port 80 will be redirected to HTTPS on port 443.</summary>
        public bool? RedirectHttpToHttps { get; set; }
        /// <summary>This field has been replaced by the `size_unit` field for all regions except in AMS2, NYC2, and SFO1. Each available load balancer size now equates to the load balancer having a set number of nodes.* `lb-small` = 1 node* `lb-medium` = 3 nodes* `lb-large` = 6 nodesYou can resize load balancers after creation up to once per hour. You cannot resize a load balancer within the first hour of its creation.</summary>
        [Obsolete("")]
        public global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_size? Size { get; set; }
        /// <summary>How many nodes the load balancer contains. Each additional node increases the load balancer&apos;s ability to manage more connections. Load balancers can be scaled up or down, and you can change the number of nodes after creation up to once per hour. This field is currently not available in the AMS2, NYC2, or SFO1 regions. Use the `size` field to scale load balancers that reside in these regions.</summary>
        public int? SizeUnit { get; set; }
        /// <summary>A status string indicating the current state of the load balancer. This can be `new`, `active`, or `errored`.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_status? Status { get; private set; }
        /// <summary>An object specifying sticky sessions settings for the load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::InfinityFlow.DigitalOcean.Client.Models.Sticky_sessions? StickySessions { get; set; }
#nullable restore
#else
        public global::InfinityFlow.DigitalOcean.Client.Models.Sticky_sessions StickySessions { get; set; }
#endif
        /// <summary>An array containing the UUIDs of the Regional load balancers to be used as target backends for a Global load balancer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? TargetLoadBalancerIds { get; set; }
#nullable restore
#else
        public List<string> TargetLoadBalancerIds { get; set; }
#endif
        /// <summary>A string indicating whether the load balancer should be a standard regional HTTP load balancer, a regional network load balancer that routes traffic at the TCP/UDP transport layer, or a global load balancer.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_type? Type { get; set; }
        /// <summary>A string specifying the UUID of the VPC to which the load balancer is assigned.</summary>
        public Guid? VpcUuid { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base"/> and sets the default values.
        /// </summary>
        public Load_balancer_base()
        {
            AdditionalData = new Dictionary<string, object>();
            Algorithm = global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_algorithm.Round_robin;
            Network = global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network.EXTERNAL;
            NetworkStack = global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network_stack.IPV4;
            Size = global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_size.LbSmall;
            Type = global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_type.REGIONAL;
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "algorithm", n => { Algorithm = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_algorithm>(); } },
                { "created_at", n => { CreatedAt = n.GetDateTimeOffsetValue(); } },
                { "disable_lets_encrypt_dns_records", n => { DisableLetsEncryptDnsRecords = n.GetBoolValue(); } },
                { "domains", n => { Domains = n.GetCollectionOfObjectValues<global::InfinityFlow.DigitalOcean.Client.Models.Domains>(global::InfinityFlow.DigitalOcean.Client.Models.Domains.CreateFromDiscriminatorValue)?.AsList(); } },
                { "enable_backend_keepalive", n => { EnableBackendKeepalive = n.GetBoolValue(); } },
                { "enable_proxy_protocol", n => { EnableProxyProtocol = n.GetBoolValue(); } },
                { "firewall", n => { Firewall = n.GetObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Lb_firewall>(global::InfinityFlow.DigitalOcean.Client.Models.Lb_firewall.CreateFromDiscriminatorValue); } },
                { "forwarding_rules", n => { ForwardingRules = n.GetCollectionOfObjectValues<global::InfinityFlow.DigitalOcean.Client.Models.Forwarding_rule>(global::InfinityFlow.DigitalOcean.Client.Models.Forwarding_rule.CreateFromDiscriminatorValue)?.AsList(); } },
                { "glb_settings", n => { GlbSettings = n.GetObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Glb_settings>(global::InfinityFlow.DigitalOcean.Client.Models.Glb_settings.CreateFromDiscriminatorValue); } },
                { "health_check", n => { HealthCheck = n.GetObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Health_check>(global::InfinityFlow.DigitalOcean.Client.Models.Health_check.CreateFromDiscriminatorValue); } },
                { "http_idle_timeout_seconds", n => { HttpIdleTimeoutSeconds = n.GetIntValue(); } },
                { "id", n => { Id = n.GetGuidValue(); } },
                { "ip", n => { Ip = n.GetStringValue(); } },
                { "ipv6", n => { Ipv6 = n.GetStringValue(); } },
                { "name", n => { Name = n.GetStringValue(); } },
                { "network", n => { Network = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network>(); } },
                { "network_stack", n => { NetworkStack = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network_stack>(); } },
                { "project_id", n => { ProjectId = n.GetStringValue(); } },
                { "redirect_http_to_https", n => { RedirectHttpToHttps = n.GetBoolValue(); } },
                { "size", n => { Size = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_size>(); } },
                { "size_unit", n => { SizeUnit = n.GetIntValue(); } },
                { "status", n => { Status = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_status>(); } },
                { "sticky_sessions", n => { StickySessions = n.GetObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Sticky_sessions>(global::InfinityFlow.DigitalOcean.Client.Models.Sticky_sessions.CreateFromDiscriminatorValue); } },
                { "target_load_balancer_ids", n => { TargetLoadBalancerIds = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "type", n => { Type = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_type>(); } },
                { "vpc_uuid", n => { VpcUuid = n.GetGuidValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_algorithm>("algorithm", Algorithm);
            writer.WriteBoolValue("disable_lets_encrypt_dns_records", DisableLetsEncryptDnsRecords);
            writer.WriteCollectionOfObjectValues<global::InfinityFlow.DigitalOcean.Client.Models.Domains>("domains", Domains);
            writer.WriteBoolValue("enable_backend_keepalive", EnableBackendKeepalive);
            writer.WriteBoolValue("enable_proxy_protocol", EnableProxyProtocol);
            writer.WriteObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Lb_firewall>("firewall", Firewall);
            writer.WriteCollectionOfObjectValues<global::InfinityFlow.DigitalOcean.Client.Models.Forwarding_rule>("forwarding_rules", ForwardingRules);
            writer.WriteObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Glb_settings>("glb_settings", GlbSettings);
            writer.WriteObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Health_check>("health_check", HealthCheck);
            writer.WriteIntValue("http_idle_timeout_seconds", HttpIdleTimeoutSeconds);
            writer.WriteStringValue("name", Name);
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network>("network", Network);
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_network_stack>("network_stack", NetworkStack);
            writer.WriteStringValue("project_id", ProjectId);
            writer.WriteBoolValue("redirect_http_to_https", RedirectHttpToHttps);
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_size>("size", Size);
            writer.WriteIntValue("size_unit", SizeUnit);
            writer.WriteObjectValue<global::InfinityFlow.DigitalOcean.Client.Models.Sticky_sessions>("sticky_sessions", StickySessions);
            writer.WriteCollectionOfPrimitiveValues<string>("target_load_balancer_ids", TargetLoadBalancerIds);
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Load_balancer_base_type>("type", Type);
            writer.WriteGuidValue("vpc_uuid", VpcUuid);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
