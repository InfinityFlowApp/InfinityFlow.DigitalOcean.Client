// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace InfinityFlow.DigitalOcean.Client.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class Redis_advanced_config : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Determines default pub/sub channels&apos; ACL for new users if ACL is not supplied. When this option is not defined, all_channels is assumed to keep backward compatibility. This option doesn&apos;t affect Redis configuration acl-pubsub-default.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_acl_channels_default? RedisAclChannelsDefault { get; set; }
        /// <summary>Redis IO thread count</summary>
        public int? RedisIoThreads { get; set; }
        /// <summary>LFU maxmemory-policy counter decay time in minutes</summary>
        public int? RedisLfuDecayTime { get; set; }
        /// <summary>Counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory-policies</summary>
        public int? RedisLfuLogFactor { get; set; }
        /// <summary>A string specifying the desired eviction policy for the Redis cluster.- `noeviction`: Don&apos;t evict any data, returns error when memory limit is reached.- `allkeys-lru:` Evict any key, least recently used (LRU) first.- `allkeys-random`: Evict keys in a random order.- `volatile-lru`: Evict keys with expiration only, least recently used (LRU) first.- `volatile-random`: Evict keys with expiration only in a random order.- `volatile-ttl`: Evict keys with expiration only, shortest time-to-live (TTL) first.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_maxmemory_policy? RedisMaxmemoryPolicy { get; set; }
        /// <summary>Set notify-keyspace-events option. Requires at least `K` or `E` and accepts any combination of the following options. Setting the parameter to `&quot;&quot;` disables notifications.- `K` &amp;mdash; Keyspace events- `E` &amp;mdash; Keyevent events- `g` &amp;mdash; Generic commands (e.g. `DEL`, `EXPIRE`, `RENAME`, ...)- `$` &amp;mdash; String commands- `l` &amp;mdash; List commands- `s` &amp;mdash; Set commands- `h` &amp;mdash; Hash commands- `z` &amp;mdash; Sorted set commands- `t` &amp;mdash; Stream commands- `d` &amp;mdash; Module key type events- `x` &amp;mdash; Expired events- `e` &amp;mdash; Evicted events- `m` &amp;mdash; Key miss events- `n` &amp;mdash; New key events- `A` &amp;mdash; Alias for `&quot;g$lshztxed&quot;`</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? RedisNotifyKeyspaceEvents { get; set; }
#nullable restore
#else
        public string RedisNotifyKeyspaceEvents { get; set; }
#endif
        /// <summary>Set number of redis databases. Changing this will cause a restart of redis service.</summary>
        public int? RedisNumberOfDatabases { get; set; }
        /// <summary>Creates an RDB dump of the database every 10 minutes that can be used  to recover data after a node crash. The database does not create the  dump if no keys have changed since the last dump. When set to `off`,  the database cannot fork services, and data can be lost if a service  is restarted or powered off. DigitalOcean Managed Caching databases  do not support the Append Only File (AOF) persistence method.</summary>
        public global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_persistence? RedisPersistence { get; set; }
        /// <summary>Set output buffer limit for pub / sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.</summary>
        public int? RedisPubsubClientOutputBufferLimit { get; set; }
        /// <summary>Require SSL to access Redis.- When enabled, Redis accepts only SSL connections on port `25061`.- When disabled, port `25060` is opened for non-SSL connections, while port `25061` remains available for SSL connections.</summary>
        public bool? RedisSsl { get; set; }
        /// <summary>Redis idle connection timeout in seconds</summary>
        public int? RedisTimeout { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config"/> and sets the default values.
        /// </summary>
        public Redis_advanced_config()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "redis_acl_channels_default", n => { RedisAclChannelsDefault = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_acl_channels_default>(); } },
                { "redis_io_threads", n => { RedisIoThreads = n.GetIntValue(); } },
                { "redis_lfu_decay_time", n => { RedisLfuDecayTime = n.GetIntValue(); } },
                { "redis_lfu_log_factor", n => { RedisLfuLogFactor = n.GetIntValue(); } },
                { "redis_maxmemory_policy", n => { RedisMaxmemoryPolicy = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_maxmemory_policy>(); } },
                { "redis_notify_keyspace_events", n => { RedisNotifyKeyspaceEvents = n.GetStringValue(); } },
                { "redis_number_of_databases", n => { RedisNumberOfDatabases = n.GetIntValue(); } },
                { "redis_persistence", n => { RedisPersistence = n.GetEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_persistence>(); } },
                { "redis_pubsub_client_output_buffer_limit", n => { RedisPubsubClientOutputBufferLimit = n.GetIntValue(); } },
                { "redis_ssl", n => { RedisSsl = n.GetBoolValue(); } },
                { "redis_timeout", n => { RedisTimeout = n.GetIntValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_acl_channels_default>("redis_acl_channels_default", RedisAclChannelsDefault);
            writer.WriteIntValue("redis_io_threads", RedisIoThreads);
            writer.WriteIntValue("redis_lfu_decay_time", RedisLfuDecayTime);
            writer.WriteIntValue("redis_lfu_log_factor", RedisLfuLogFactor);
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_maxmemory_policy>("redis_maxmemory_policy", RedisMaxmemoryPolicy);
            writer.WriteStringValue("redis_notify_keyspace_events", RedisNotifyKeyspaceEvents);
            writer.WriteIntValue("redis_number_of_databases", RedisNumberOfDatabases);
            writer.WriteEnumValue<global::InfinityFlow.DigitalOcean.Client.Models.Redis_advanced_config_redis_persistence>("redis_persistence", RedisPersistence);
            writer.WriteIntValue("redis_pubsub_client_output_buffer_limit", RedisPubsubClientOutputBufferLimit);
            writer.WriteBoolValue("redis_ssl", RedisSsl);
            writer.WriteIntValue("redis_timeout", RedisTimeout);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
