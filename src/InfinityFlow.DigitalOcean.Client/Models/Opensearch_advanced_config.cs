// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace InfinityFlow.DigitalOcean.Client.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class Opensearch_advanced_config : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Specifices whether to allow automatic creation of indices.</summary>
        public bool? ActionAutoCreateIndexEnabled { get; set; }
        /// <summary>Specifies whether to require explicit index names when deleting indices.</summary>
        public bool? ActionDestructiveRequiresName { get; set; }
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Maximum number of shards allowed per data node.</summary>
        public int? ClusterMaxShardsPerNode { get; set; }
        /// <summary>Maximum concurrent incoming/outgoing shard recoveries (normally replicas) are allowed to happen per node .</summary>
        public int? ClusterRoutingAllocationNodeConcurrentRecoveries { get; set; }
        /// <summary>Specifies whether to allow security audit logging.</summary>
        public bool? EnableSecurityAudit { get; set; }
        /// <summary>Maximum content length for HTTP requests to the OpenSearch HTTP API, in bytes.</summary>
        public int? HttpMaxContentLengthBytes { get; set; }
        /// <summary>Maximum size of allowed headers, in bytes.</summary>
        public int? HttpMaxHeaderSizeBytes { get; set; }
        /// <summary>Maximum length of an HTTP URL, in bytes.</summary>
        public int? HttpMaxInitialLineLengthBytes { get; set; }
        /// <summary>Maximum amount of heap memory used for field data cache, expressed as a percentage. Decreasing the value too much will increase overhead of loading field data. Increasing the value too much will decrease amount of heap available for other operations.</summary>
        public int? IndicesFielddataCacheSizePercentage { get; set; }
        /// <summary>Total amount of heap used for indexing buffer before writing segments to disk, expressed as a percentage. Too low value will slow down indexing; too high value will increase indexing performance but causes performance issues for query performance.</summary>
        public int? IndicesMemoryIndexBufferSizePercentage { get; set; }
        /// <summary>Maximum amount of heap used for indexing buffer before writing segments to disk, in mb. Works in conjunction with indices_memory_index_buffer_size_percentage, each being enforced. The default is unbounded.</summary>
        public int? IndicesMemoryMaxIndexBufferSizeMb { get; set; }
        /// <summary>Minimum amount of heap used for indexing buffer before writing segments to disk, in mb. Works in conjunction with indices_memory_index_buffer_size_percentage, each being enforced.</summary>
        public int? IndicesMemoryMinIndexBufferSizeMb { get; set; }
        /// <summary>Maximum amount of heap used for query cache.  Too low value will decrease query performance and increase performance for other operations; too high value will cause issues with other functionality.</summary>
        public int? IndicesQueriesCacheSizePercentage { get; set; }
        /// <summary>Maximum number of clauses Lucene BooleanQuery can have.  Only increase it if necessary, as it may cause performance issues.</summary>
        public int? IndicesQueryBoolMaxClauseCount { get; set; }
        /// <summary>Maximum number of file chunks sent in parallel for each recovery.</summary>
        public int? IndicesRecoveryMaxConcurrentFileChunks { get; set; }
        /// <summary>Limits total inbound and outbound recovery traffic for each node, expressed in mb per second. Applies to both peer recoveries as well as snapshot recoveries (i.e., restores from a snapshot).</summary>
        public int? IndicesRecoveryMaxMbPerSec { get; set; }
        /// <summary>Specifies whether ISM is enabled or not.</summary>
        public bool? IsmEnabled { get; set; }
        /// <summary>Specifies whether audit history is enabled or not. The logs from ISM are automatically indexed to a logs document.</summary>
        public bool? IsmHistoryEnabled { get; set; }
        /// <summary>Maximum age before rolling over the audit history index, in hours.</summary>
        public int? IsmHistoryMaxAgeHours { get; set; }
        /// <summary>Maximum number of documents before rolling over the audit history index.</summary>
        public int? IsmHistoryMaxDocs { get; set; }
        /// <summary>The time between rollover checks for the audit history index, in hours.</summary>
        public int? IsmHistoryRolloverCheckPeriodHours { get; set; }
        /// <summary>Length of time long audit history indices are kept, in days.</summary>
        public int? IsmHistoryRolloverRetentionPeriodDays { get; set; }
        /// <summary>Compatibility mode sets OpenSearch to report its version as 7.10 so clients continue to work.</summary>
        public bool? OverrideMainResponseVersion { get; set; }
        /// <summary>Enable or disable filtering of alerting by backend roles.</summary>
        public bool? PluginsAlertingFilterByBackendRolesEnabled { get; set; }
        /// <summary>Allowlist of remote IP addresses for reindexing. Changing this value will cause all OpenSearch instances to restart.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<string>? ReindexRemoteWhitelist { get; set; }
#nullable restore
#else
        public List<string> ReindexRemoteWhitelist { get; set; }
#endif
        /// <summary>Limits the number of inline script compilations within a period of time. Default is use-context</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ScriptMaxCompilationsRate { get; set; }
#nullable restore
#else
        public string ScriptMaxCompilationsRate { get; set; }
#endif
        /// <summary>Maximum number of aggregation buckets allowed in a single response.</summary>
        public int? SearchMaxBuckets { get; set; }
        /// <summary>Size of queue for operations in the analyze thread pool.</summary>
        public int? ThreadPoolAnalyzeQueueSize { get; set; }
        /// <summary>Number of workers in the analyze operation thread pool.  Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.</summary>
        public int? ThreadPoolAnalyzeSize { get; set; }
        /// <summary>Number of workers in the force merge operation thread pool. This pool is used for forcing a merge between shards of one or more indices. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.</summary>
        public int? ThreadPoolForceMergeSize { get; set; }
        /// <summary>Size of queue for operations in the get thread pool.</summary>
        public int? ThreadPoolGetQueueSize { get; set; }
        /// <summary>Number of workers in the get operation thread pool.  Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.</summary>
        public int? ThreadPoolGetSize { get; set; }
        /// <summary>Size of queue for operations in the search thread pool.</summary>
        public int? ThreadPoolSearchQueueSize { get; set; }
        /// <summary>Number of workers in the search operation thread pool.  Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.</summary>
        public int? ThreadPoolSearchSize { get; set; }
        /// <summary>Size of queue for operations in the search throttled thread pool.</summary>
        public int? ThreadPoolSearchThrottledQueueSize { get; set; }
        /// <summary>Number of workers in the search throttled operation thread pool. This pool is used for searching frozen indices. Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.</summary>
        public int? ThreadPoolSearchThrottledSize { get; set; }
        /// <summary>Size of queue for operations in the write thread pool.</summary>
        public int? ThreadPoolWriteQueueSize { get; set; }
        /// <summary>Number of workers in the write operation thread pool.  Do note this may have maximum value depending on CPU count - value is automatically lowered if set to higher than maximum value.</summary>
        public int? ThreadPoolWriteSize { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::InfinityFlow.DigitalOcean.Client.Models.Opensearch_advanced_config"/> and sets the default values.
        /// </summary>
        public Opensearch_advanced_config()
        {
            AdditionalData = new Dictionary<string, object>();
            ScriptMaxCompilationsRate = "use-context";
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::InfinityFlow.DigitalOcean.Client.Models.Opensearch_advanced_config"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::InfinityFlow.DigitalOcean.Client.Models.Opensearch_advanced_config CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::InfinityFlow.DigitalOcean.Client.Models.Opensearch_advanced_config();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "action_auto_create_index_enabled", n => { ActionAutoCreateIndexEnabled = n.GetBoolValue(); } },
                { "action_destructive_requires_name", n => { ActionDestructiveRequiresName = n.GetBoolValue(); } },
                { "cluster_max_shards_per_node", n => { ClusterMaxShardsPerNode = n.GetIntValue(); } },
                { "cluster_routing_allocation_node_concurrent_recoveries", n => { ClusterRoutingAllocationNodeConcurrentRecoveries = n.GetIntValue(); } },
                { "enable_security_audit", n => { EnableSecurityAudit = n.GetBoolValue(); } },
                { "http_max_content_length_bytes", n => { HttpMaxContentLengthBytes = n.GetIntValue(); } },
                { "http_max_header_size_bytes", n => { HttpMaxHeaderSizeBytes = n.GetIntValue(); } },
                { "http_max_initial_line_length_bytes", n => { HttpMaxInitialLineLengthBytes = n.GetIntValue(); } },
                { "indices_fielddata_cache_size_percentage", n => { IndicesFielddataCacheSizePercentage = n.GetIntValue(); } },
                { "indices_memory_index_buffer_size_percentage", n => { IndicesMemoryIndexBufferSizePercentage = n.GetIntValue(); } },
                { "indices_memory_max_index_buffer_size_mb", n => { IndicesMemoryMaxIndexBufferSizeMb = n.GetIntValue(); } },
                { "indices_memory_min_index_buffer_size_mb", n => { IndicesMemoryMinIndexBufferSizeMb = n.GetIntValue(); } },
                { "indices_queries_cache_size_percentage", n => { IndicesQueriesCacheSizePercentage = n.GetIntValue(); } },
                { "indices_query_bool_max_clause_count", n => { IndicesQueryBoolMaxClauseCount = n.GetIntValue(); } },
                { "indices_recovery_max_concurrent_file_chunks", n => { IndicesRecoveryMaxConcurrentFileChunks = n.GetIntValue(); } },
                { "indices_recovery_max_mb_per_sec", n => { IndicesRecoveryMaxMbPerSec = n.GetIntValue(); } },
                { "ism_enabled", n => { IsmEnabled = n.GetBoolValue(); } },
                { "ism_history_enabled", n => { IsmHistoryEnabled = n.GetBoolValue(); } },
                { "ism_history_max_age_hours", n => { IsmHistoryMaxAgeHours = n.GetIntValue(); } },
                { "ism_history_max_docs", n => { IsmHistoryMaxDocs = n.GetIntValue(); } },
                { "ism_history_rollover_check_period_hours", n => { IsmHistoryRolloverCheckPeriodHours = n.GetIntValue(); } },
                { "ism_history_rollover_retention_period_days", n => { IsmHistoryRolloverRetentionPeriodDays = n.GetIntValue(); } },
                { "override_main_response_version", n => { OverrideMainResponseVersion = n.GetBoolValue(); } },
                { "plugins_alerting_filter_by_backend_roles_enabled", n => { PluginsAlertingFilterByBackendRolesEnabled = n.GetBoolValue(); } },
                { "reindex_remote_whitelist", n => { ReindexRemoteWhitelist = n.GetCollectionOfPrimitiveValues<string>()?.AsList(); } },
                { "script_max_compilations_rate", n => { ScriptMaxCompilationsRate = n.GetStringValue(); } },
                { "search_max_buckets", n => { SearchMaxBuckets = n.GetIntValue(); } },
                { "thread_pool_analyze_queue_size", n => { ThreadPoolAnalyzeQueueSize = n.GetIntValue(); } },
                { "thread_pool_analyze_size", n => { ThreadPoolAnalyzeSize = n.GetIntValue(); } },
                { "thread_pool_force_merge_size", n => { ThreadPoolForceMergeSize = n.GetIntValue(); } },
                { "thread_pool_get_queue_size", n => { ThreadPoolGetQueueSize = n.GetIntValue(); } },
                { "thread_pool_get_size", n => { ThreadPoolGetSize = n.GetIntValue(); } },
                { "thread_pool_search_queue_size", n => { ThreadPoolSearchQueueSize = n.GetIntValue(); } },
                { "thread_pool_search_size", n => { ThreadPoolSearchSize = n.GetIntValue(); } },
                { "thread_pool_search_throttled_queue_size", n => { ThreadPoolSearchThrottledQueueSize = n.GetIntValue(); } },
                { "thread_pool_search_throttled_size", n => { ThreadPoolSearchThrottledSize = n.GetIntValue(); } },
                { "thread_pool_write_queue_size", n => { ThreadPoolWriteQueueSize = n.GetIntValue(); } },
                { "thread_pool_write_size", n => { ThreadPoolWriteSize = n.GetIntValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteBoolValue("action_auto_create_index_enabled", ActionAutoCreateIndexEnabled);
            writer.WriteBoolValue("action_destructive_requires_name", ActionDestructiveRequiresName);
            writer.WriteIntValue("cluster_max_shards_per_node", ClusterMaxShardsPerNode);
            writer.WriteIntValue("cluster_routing_allocation_node_concurrent_recoveries", ClusterRoutingAllocationNodeConcurrentRecoveries);
            writer.WriteBoolValue("enable_security_audit", EnableSecurityAudit);
            writer.WriteIntValue("http_max_content_length_bytes", HttpMaxContentLengthBytes);
            writer.WriteIntValue("http_max_header_size_bytes", HttpMaxHeaderSizeBytes);
            writer.WriteIntValue("http_max_initial_line_length_bytes", HttpMaxInitialLineLengthBytes);
            writer.WriteIntValue("indices_fielddata_cache_size_percentage", IndicesFielddataCacheSizePercentage);
            writer.WriteIntValue("indices_memory_index_buffer_size_percentage", IndicesMemoryIndexBufferSizePercentage);
            writer.WriteIntValue("indices_memory_max_index_buffer_size_mb", IndicesMemoryMaxIndexBufferSizeMb);
            writer.WriteIntValue("indices_memory_min_index_buffer_size_mb", IndicesMemoryMinIndexBufferSizeMb);
            writer.WriteIntValue("indices_queries_cache_size_percentage", IndicesQueriesCacheSizePercentage);
            writer.WriteIntValue("indices_query_bool_max_clause_count", IndicesQueryBoolMaxClauseCount);
            writer.WriteIntValue("indices_recovery_max_concurrent_file_chunks", IndicesRecoveryMaxConcurrentFileChunks);
            writer.WriteIntValue("indices_recovery_max_mb_per_sec", IndicesRecoveryMaxMbPerSec);
            writer.WriteBoolValue("ism_enabled", IsmEnabled);
            writer.WriteBoolValue("ism_history_enabled", IsmHistoryEnabled);
            writer.WriteIntValue("ism_history_max_age_hours", IsmHistoryMaxAgeHours);
            writer.WriteIntValue("ism_history_max_docs", IsmHistoryMaxDocs);
            writer.WriteIntValue("ism_history_rollover_check_period_hours", IsmHistoryRolloverCheckPeriodHours);
            writer.WriteIntValue("ism_history_rollover_retention_period_days", IsmHistoryRolloverRetentionPeriodDays);
            writer.WriteBoolValue("override_main_response_version", OverrideMainResponseVersion);
            writer.WriteBoolValue("plugins_alerting_filter_by_backend_roles_enabled", PluginsAlertingFilterByBackendRolesEnabled);
            writer.WriteCollectionOfPrimitiveValues<string>("reindex_remote_whitelist", ReindexRemoteWhitelist);
            writer.WriteStringValue("script_max_compilations_rate", ScriptMaxCompilationsRate);
            writer.WriteIntValue("search_max_buckets", SearchMaxBuckets);
            writer.WriteIntValue("thread_pool_analyze_queue_size", ThreadPoolAnalyzeQueueSize);
            writer.WriteIntValue("thread_pool_analyze_size", ThreadPoolAnalyzeSize);
            writer.WriteIntValue("thread_pool_force_merge_size", ThreadPoolForceMergeSize);
            writer.WriteIntValue("thread_pool_get_queue_size", ThreadPoolGetQueueSize);
            writer.WriteIntValue("thread_pool_get_size", ThreadPoolGetSize);
            writer.WriteIntValue("thread_pool_search_queue_size", ThreadPoolSearchQueueSize);
            writer.WriteIntValue("thread_pool_search_size", ThreadPoolSearchSize);
            writer.WriteIntValue("thread_pool_search_throttled_queue_size", ThreadPoolSearchThrottledQueueSize);
            writer.WriteIntValue("thread_pool_search_throttled_size", ThreadPoolSearchThrottledSize);
            writer.WriteIntValue("thread_pool_write_queue_size", ThreadPoolWriteQueueSize);
            writer.WriteIntValue("thread_pool_write_size", ThreadPoolWriteSize);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
